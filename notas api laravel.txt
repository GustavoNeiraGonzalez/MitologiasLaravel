--
INSTALACION

composer global require laravel/installer

laravel new example-app

cd example-app

(creaste el proyecto laravel)
pero falta que laravel pueda ser usado como api asi que:

php artisan install:api
---
---
configurar .env:

para poder conectarte a tu bd tienes que configurar la conexion a la misma,
usando xampp usarias el puerto que xampp usa, en mi caso 3310 ejemplo

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3310
DB_DATABASE=MitologiasLaravel
DB_USERNAME=root
DB_PASSWORD=

---
crear tablas de datos

antes de poder usar datos en tu bd tienes que crear datos personalizados segun tus necesidades
por ejemplo usaremos users tal cual deberia venir por defecto pero tambien crearemos la tabla mitologias mitologias
con el comando:

php artisan make:model Mitologias --all

luego de esto nos podemos dirigir a: database/migrations y el archivo que diga la fecha y create_mitologias_table
donde colocaremos los tipos de datos que tendra la tabla de la bdd dentro de la funcion up():

    public function up(): void
    {
  	Schema::create('mitologias', function (Blueprint $table) {
            $table->id();
            $table->timestamps();
            $table->foreignId('user_id')->nullable()->constrained()->onDelete('cascade');
            $table->text('Historia');
        });
    }

donde foreignId hace referencias a las relacion que tiene con la tabla usuario y si se borra un usuario tambien sus 
mitologias asociadas gracias a ondelete y constrained es necesario porque configura las relaciones de claves
y nullable indica que puede ser null, en este caso es necesario porque una mitologia no necesariamente estaria asociado
 a algun usuario
e historia es tipo TEXT porque text permite mas caracteres que un STRING

luego ejecutar:
php artisan migrate
-------------------------
ERROR DE LOGICA

en la anterior hemos relacionado usuarios a mitologias, sin embargo la logica del programa indica que un usuario solo da
"guardar" mitologia para verla despues, con ondelete('cascade') estariamos borrando la mitologia si el usuario es eliminado
para corregirlo creamos 2 nuevas migraciones 1 para crear una tabla intermedia y otra para eliminar la clave foranea dentro de 
la tabla mitologias

php artisan make:migration remove_user_id_from_mitologias_table --table=mitologias
php artisan make:migration mitologia_users

en remove_user_id..... haremos esto dentro de up() y down() 
(
  public function up(): void
    {
        Schema::table('mitologias', function (Blueprint $table) {
            //
            $table->dropForeign(['user_id']);
            $table->dropColumn('user_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('mitologias', function (Blueprint $table) {
            //
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
        });
    }
)
y dentro de mitologia_users creamos las relaciones
(
public function up(): void
    {
        //
        Schema::create('mitologia_user', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->foreignId('mitologia_id')->constrained('mitologias')->onDelete('cascade');
            $table->timestamps();
        });
    }
)
y finalmente correr las migraciones
php artisan migrate
----------------------
ultimo paso relacion de tablas:

ahora debes dirigirte a models y especificar las relaciones entre tablas, en este caso usando una tabla intermedia mitologia_user
será ligeramente diferente:

dentro de models/Mitologias
(
    public function usuariosQueGuardaron()
    {
        return $this->belongsToMany(User::class, 'mitologia_user', 'mitologia_id', 'user_id');
    }
)
y dentro de models/Users
(
  public function mitologiasGuardadas()
    {
        return $this->belongsToMany(Mitologias::class, 'mitologia_user', 'user_id', 'mitologia_id');
    }
)
ahora solo queda probar que este correcto creando datos
-------------------------
ROUTES API Y CONTROLER
(necesitamos haber instalado api que se indica al principio de las notas en instalacion)
antes de probar si estan correctas las relaciones entre tablas primero vamos a app/http/controller/mitologiascontroller.php
y en el controlador mostraremos un texto simple
(
	public function index()
	{
        	//
        	return "obteniendo mitologias";
    	}
)
ahora retornará "obteniendo mitologias" pero para verlo nos dirigimos a routes/api.php
primero debemos importar el controlador y luego crear una ruta que use la funcion index del controlador
(
	use App\Http\Controllers\MitologiasController;

	Route::get('/mitologias', [MitologiasController::class, 'index']);
)
ahora para ver si funciona, nos dirigimos a la url correspondiente en este caso http://127.0.0.1:8000/api/mitologias
NOTA COMO ES API SE USA API EN LA URL

viendo que se ve exitosamente el texto, ahora para retornar los datos de mitologias, simplemente nos volvemos al controller y modificamos index
(
   public function index()
    {
        //
        $mitologias = Mitologias::all();//aqui se recupera todos los datos de mitologias y se almacena en data

        if ($mitologias->isEmpty()){//aqui se verifica y muestra mensaje error si esta vacia los datos de mitologias
            $data = [
                'message' =>'No se encontraron mitologías' ,
                'status' =>404
            ];
            return response()->json($data, 404);
        }
 	$data = [
                'Mitologias' =>$mitologias ,
                'status' =>200
            ];
        return response()->json($data, 200);
    }

)
el resultado daria los datos en formaton json y si no hay datos, mostrar el mensaje correspondiente en el mismo formato
-------------------------
STORE
PARA INGRESAR LA PRIMERA MITOLOGIA USAREMOS STORE DEL CONTROLADOR MITOLogias

primero importamos validator y Request, (request importante o te saldra un error 500 internal server error que me costo allar que no lo tenia importado)
use Illiminate\Support\Facades\Validator;
use Illuminate\Http\Request;

ahora en store haremos algo asi
(
public function store(Request $request)
  {
      $validator = Validator::make($request->all(), [// Se crean las reglas de validación
            'Historia' => 'required|string|max:4000',
        ]);
        if ($validator->fails()) {// Verifica si la validación falla
            $data = [
                'message' => 'Error de validación',
                'errors' => $validator->errors(),
                'status' => 422
            ];
            return response()->json($data, 422);
        }

        try {
            $mitologias = Mitologias::create([//crea nuevo registro
                'Historia' => $request->Historia
            ]);

            $data = [//mensaje de exito
                'message' => 'Mitología creada exitosamente',
                'Mitologia' => $mitologias,
                'status' => 201
            ]; n
            return response()->json($data, 201);//retorna mensaje de exito

        } catch (\Exception $e) {//captura errores
            $data = [
                'message' => 'Error al crear la mitología',
                'error' => $e->getMessage(),
                'status' => 500
            ];
            return response()->json($data, 500);//retorna mensaje de error
        }
  }
)
utilizamos validator para verificar que el campo Historia no este vacio, que sea string y un maximo de 4000 caracteres
si no es el caso mandaremos un mensaje de error, luego un try catch para manejar errores, intentamos crear una nueva
mitologia
(NOTA falto el campo titulo asi que fuera de esto lo he creado a traves de migraciones luego modificar en models mitologias y controller mitologias)

luego nos vamos a routes/api a crear la ruta (no importamos el controlador porque ya lo hicimos anteriormente)

Route::post('/mitologias', [MitologiasController::class, 'store']);

y finalmente pruebas que funcione la peticion, en este caso voy a la extension thunder client
con una peticion post y la url http://127.0.0.1:8000/api/mitologias
en el campo body, json 
{"Historia":"ola",
"titulo":"saludos"} (titulo agregado fuera de las instrucciones)

tambien puedes ver los mensajes de errores por faltar algun campo o pasar el limite de caracteres

-------------------------
SHOW
para buscar la informacion de un usuario especifico:

primero nos vamos al controlador mitologias
y en la funcion show quedaria asi:

(
  public function show($id)
    {
        //
        $mitologia = Mitologias::find($id);//busca mitologia por id
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        $data = [//muestra mitologia encontrada
            'Mitologia' => $mitologia,
            'status' => 200
        ];
        return response()->json($data, 200);//retorna mensaje de exito
    }
)

donde buscandos mitologia por ID, un if para mostrar mensaje de error si es que no se ha encontrado una mitologia
y si la ha encontrado retornar la mitologia especifica

luego nos vamos a api y creamos la ruta, que es sencillo porque ya lo hemos visto
(
//ruta para mostrar mitologia por id
Route::get('/mitologias/{id}', [MitologiasController::class, 'show']);
)

y ahora probar que funcione en la extension thunder client o donde quieras
----
DELETE
eliminar una mitologia:

esta funcion será bastanet similar a show, asi que nos vamos al controlador mitologias
y en la funcion delete será asi:

(
   public function destroy($id)
    {
        //
        $mitologia = Mitologias::find($id);//busca mitologia por id
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        $titulo = $mitologia->titulo; // Guarda el título antes de eliminar la mitología
        $mitologia->delete();//elimina mitologia

        $data = [//mensaje de exito
            'message' => 'Mitología eliminada exitosamente',
            'titulo' => $titulo,
            'status' => 200
        ];
        return response()->json($data, 200);
    }
)
y la diferencia es que aqui usaremos delete() tambien guardamos titulo de la mitologia antes de borrarlo para mostrar que titulo de mitologia
hemos borrado


en api agregamos simplemente la ruta y listo

(
//ruta para eliminar mitologia por id
Route::delete('/mitologias/{id}', [MitologiasController::class, 'destroy']);
)

------
PUT UPDATE

para actualizar una mitologia tambien buscamos por id pero aqui validamos tambien que los datos que actualizaremos esten correctos
para ello nos vamos a controlador mitologias
y en la funcion update
(
  public function update(Request $request,$id)
    {
        $mitologia = Mitologias::find($id);//busca mitologia por id
        //
        $validator = Validator::make($request->all(), [// Se crean las reglas de validación
            'Historia' => 'required|string|max:4000',
            'titulo' => 'required|string|max:25',
        ]);
        if ($validator->fails()) {// Verifica si la validación falla
            $data = [
                'message' => 'Error de validación',
                'errors' => $validator->errors(),
                'status' => 422
            ];
            return response()->json($data, 422);//retorna mensaje de error
        }
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);//retorna mensaje de error
        }
        try {
            $mitologia->Historia = $request->Historia;//actualiza historia
            $mitologia->titulo = $request->titulo;//actualiza titulo

            $mitologia->save();//actualiza mitologia

            $data = [//mensaje de exito
                'message' => 'Mitología actualizada exitosamente',
                'Mitologia' => $mitologia->titulo,
                'status' => 200
            ];
            return response()->json($data, 200);

        } catch (\Exception $e) {//captura errores
            $data = [
                'message' => 'Error al actualizar la mitología',
                'error' => $e->getMessage(),
                'status' => 500
            ];
            return response()->json($data, 500);//retorna mensaje de error
        }
    }
)

aqui hemos buscado por id, hemos validado que los datos a actualizar sean correctos y ver si la mitologia existia 
con sus respectivos mensajes de error,
luego en un try catch, hemos actualizado los datos buscados por id de la mitologia con los datos enviados en la peticion
en request, y luego guardamos con save. si todo va bien es un mensaje con exito si va mal se usa el catch

luego en api creamos al ruta

(
//ruta para actualizar mitologia por id
Route::put('/mitologias/{id}', [MitologiasController::class, 'update']);
)

y simplemente probamos que funcione

---------------------------
PATCH
CUANDO MODIFICAMOS PARCIALMENTE ALGUNOS DATOS

como queremos modificar no todos los datos de la mitologia haremos casi lo mismo en mitologia controler
con ligeras diferencias:

(
    public function updatePartial(Request $request,$id)
    {
        $mitologia = Mitologias::find($id);//busca mitologia por id
        //
        $validator = Validator::make($request->all(), [// Se crean las reglas de validación
            'Historia' => '|string|max:4000',
            'titulo' => '|string|max:25',
        ]);
        if ($validator->fails()) {// Verifica si la validación falla
            $data = [
                'message' => 'Error de validación',
                'errors' => $validator->errors(),
                'status' => 422
            ];
            return response()->json($data, 422);//retorna mensaje de error
        }
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);//retorna mensaje de error
        }
        try {
            if ($request->has('Historia')) {
                $mitologia->Historia = $request->Historia;//actualiza historia
            }
            if ($request->has('titulo')) {
                $mitologia->titulo = $request->titulo;//actualiza titulo
            }
            $mitologia->save();//actualiza mitologia
            $data = [//mensaje de exito
                'message' => 'Mitología actualizada exitosamente',
                'Mitologia' => $mitologia->titulo,
                'status' => 200
            ];
            return response()->json($data, 200);

        } catch (\Exception $e) {//captura errores
            $data = [
                'message' => 'Error al actualizar la mitología',
                'error' => $e->getMessage(),
                'status' => 500
            ];
            return response()->json($data, 500);//retorna mensaje de error
        }
    }
)
DIFERENCIAS CON LA FUNCION UPDATE:
-EN VALIDATOR los datos no tienen required  por lo que no dara error si llegan vacios en la peticion
-EN EL TRY CUANDO QUEREMOS MODIFICAR LOS DATOS DE MITOLOGIAS usamos un if para modificar si el campo del request no esta vacio,
 si esta vacio no se modifica

luego nos vamos a api y creamos la ruta
(
//ruta para actualizar parcialmente la mitologia por id
Route::patch('/mitologias/{id}', [MitologiasController::class, 'updatePartial']);
)

y luego simplemente probamos que se modifiquen sin presentar todos los datos y los datos que no estamos modificando que no se cambien

----
EXPLICACIONES QUE FALTAN EN MITOLOGIAS:
-PODER HACER LA UNION ENTRE TABLAS USER Y MITOLOGIAS (tabla intermedia mitologia_user) 
AL CREAR DATOS (en logica de aplicacion es que le das a guardar como favorito)

-QUE HACER CON LOS ESPACIOS EN EL CAMPO "Historia" DE MITOLOGIAS es decir al ser una historia hay un orden en el texto que se debe seguir
con espacios

buen tutorial en youtube https://www.youtube.com/watch?v=eLI8c_NtkBk&t=1165s
