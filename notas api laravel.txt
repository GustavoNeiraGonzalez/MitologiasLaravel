--
INSTALACION

composer global require laravel/installer

laravel new example-app

cd example-app

(creaste el proyecto laravel)
pero falta que laravel pueda ser usado como api asi que:

php artisan install:api
---
---
configurar .env:

para poder conectarte a tu bd tienes que configurar la conexion a la misma,
usando xampp usarias el puerto que xampp usa, en mi caso 3310 ejemplo

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3310
DB_DATABASE=MitologiasLaravel
DB_USERNAME=root
DB_PASSWORD=

------------
crear tablas de datos

antes de poder usar datos en tu bd tienes que crear datos personalizados segun tus necesidades
por ejemplo usaremos users tal cual deberia venir por defecto pero tambien crearemos la tabla mitologias mitologias
con el comando:

php artisan make:model Mitologias --all

luego de esto nos podemos dirigir a: database/migrations y el archivo que diga la fecha y create_mitologias_table
donde colocaremos los tipos de datos que tendra la tabla de la bdd dentro de la funcion up():

    public function up(): void
    {
  	Schema::create('mitologias', function (Blueprint $table) {
            $table->id();
            $table->timestamps();
            $table->foreignId('user_id')->nullable()->constrained()->onDelete('cascade');
            $table->text('Historia');
        });
    }

donde foreignId hace referencias a las relacion que tiene con la tabla usuario y si se borra un usuario tambien sus 
mitologias asociadas gracias a ondelete y constrained es necesario porque configura las relaciones de claves
y nullable indica que puede ser null, en este caso es necesario porque una mitologia no necesariamente estaria asociado
 a algun usuario
e historia es tipo TEXT porque text permite mas caracteres que un STRING

luego ejecutar:
php artisan migrate




-------------------------
ERROR DE LOGICA

en la anterior hemos relacionado usuarios a mitologias, sin embargo la logica del programa indica que un usuario solo da
"guardar" mitologia para verla despues, con ondelete('cascade') estariamos borrando la mitologia si el usuario es eliminado
para corregirlo creamos 2 nuevas migraciones 1 para crear una tabla intermedia y otra para eliminar la clave foranea dentro de 
la tabla mitologias

php artisan make:migration remove_user_id_from_mitologias_table --table=mitologias
php artisan make:migration mitologia_users

en remove_user_id..... haremos esto dentro de up() y down() 
(
  public function up(): void
    {
        Schema::table('mitologias', function (Blueprint $table) {
            //
            $table->dropForeign(['user_id']);
            $table->dropColumn('user_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('mitologias', function (Blueprint $table) {
            //
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
        });
    }
)
y dentro de mitologia_users creamos las relaciones
(
public function up(): void
    {
        //
        Schema::create('mitologia_user', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->foreignId('mitologia_id')->constrained('mitologias')->onDelete('cascade');
            $table->timestamps();
        });
    }
)
y finalmente correr las migraciones
php artisan migrate

----------------------
ultimo paso RELACION ENTRE TABLAS:

ahora debes dirigirte a models y especificar las relaciones entre tablas, en este caso usando una tabla intermedia mitologia_user
será ligeramente diferente:

dentro de models/Mitologias
(
    public function usuariosQueGuardaron()
    {
        return $this->belongsToMany(User::class, 'mitologia_user', 'mitologia_id', 'user_id');
    }
)
y dentro de models/Users
(
  public function mitologiasGuardadas()
    {
        return $this->belongsToMany(Mitologias::class, 'mitologia_user', 'user_id', 'mitologia_id');
    }
)
ahora solo queda probar que este correcto creando datos
-------------------------
ROUTES API Y CONTROLER
(necesitamos haber instalado api que se indica al principio de las notas en instalacion)
antes de probar si estan correctas las relaciones entre tablas primero vamos a app/http/controller/mitologiascontroller.php
y en el controlador mostraremos un texto simple
(
	public function index()
	{
        	//
        	return "obteniendo mitologias";
    	}
)
ahora retornará "obteniendo mitologias" pero para verlo nos dirigimos a routes/api.php
primero debemos importar el controlador y luego crear una ruta que use la funcion index del controlador
(
	use App\Http\Controllers\MitologiasController;

	Route::get('/mitologias', [MitologiasController::class, 'index']);
)
ahora para ver si funciona, nos dirigimos a la url correspondiente en este caso http://127.0.0.1:8000/api/mitologias
NOTA COMO ES API SE USA API EN LA URL

viendo que se ve exitosamente el texto, ahora para retornar los datos de mitologias, simplemente nos volvemos al controller y modificamos index
(
   public function index()
    {
        //
        $mitologias = Mitologias::all();//aqui se recupera todos los datos de mitologias y se almacena en data

        if ($mitologias->isEmpty()){//aqui se verifica y muestra mensaje error si esta vacia los datos de mitologias
            $data = [
                'message' =>'No se encontraron mitologías' ,
                'status' =>404
            ];
            return response()->json($data, 404);
        }
 	$data = [
                'Mitologias' =>$mitologias ,
                'status' =>200
            ];
        return response()->json($data, 200);
    }

)
el resultado daria los datos en formaton json y si no hay datos, mostrar el mensaje correspondiente en el mismo formato
-------------------------
STORE
PARA INGRESAR LA PRIMERA MITOLOGIA USAREMOS STORE DEL CONTROLADOR MITOLogias

primero importamos validator y Request, (request importante o te saldra un error 500 internal server error que me costo allar que no lo tenia importado)
use Illiminate\Support\Facades\Validator;
use Illuminate\Http\Request;

ahora en store haremos algo asi
(
public function store(Request $request)
  {
      $validator = Validator::make($request->all(), [// Se crean las reglas de validación
            'Historia' => 'required|string|max:4000',
        ]);
        if ($validator->fails()) {// Verifica si la validación falla
            $data = [
                'message' => 'Error de validación',
                'errors' => $validator->errors(),
                'status' => 422
            ];
            return response()->json($data, 422);
        }

        try {
            $mitologias = Mitologias::create([//crea nuevo registro
                'Historia' => $request->Historia
            ]);

            $data = [//mensaje de exito
                'message' => 'Mitología creada exitosamente',
                'Mitologia' => $mitologias,
                'status' => 201
            ]; n
            return response()->json($data, 201);//retorna mensaje de exito

        } catch (\Exception $e) {//captura errores
            $data = [
                'message' => 'Error al crear la mitología',
                'error' => $e->getMessage(),
                'status' => 500
            ];
            return response()->json($data, 500);//retorna mensaje de error
        }
  }
)
utilizamos validator para verificar que el campo Historia no este vacio, que sea string y un maximo de 4000 caracteres
si no es el caso mandaremos un mensaje de error, luego un try catch para manejar errores, intentamos crear una nueva
mitologia
(NOTA falto el campo titulo asi que fuera de esto lo he creado a traves de migraciones luego modificar en models mitologias y controller mitologias)

luego nos vamos a routes/api a crear la ruta (no importamos el controlador porque ya lo hicimos anteriormente)

Route::post('/mitologias', [MitologiasController::class, 'store']);

y finalmente pruebas que funcione la peticion, en este caso voy a la extension thunder client
con una peticion post y la url http://127.0.0.1:8000/api/mitologias
en el campo body, json 
{"Historia":"ola",
"titulo":"saludos"} (titulo agregado fuera de las instrucciones)

tambien puedes ver los mensajes de errores por faltar algun campo o pasar el limite de caracteres

-------------------------
SHOW
para buscar la informacion de un usuario especifico:

primero nos vamos al controlador mitologias
y en la funcion show quedaria asi:

(
  public function show($id)
    {
        //
        $mitologia = Mitologias::find($id);//busca mitologia por id
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        $data = [//muestra mitologia encontrada
            'Mitologia' => $mitologia,
            'status' => 200
        ];
        return response()->json($data, 200);//retorna mensaje de exito
    }
)

donde buscandos mitologia por ID, un if para mostrar mensaje de error si es que no se ha encontrado una mitologia
y si la ha encontrado retornar la mitologia especifica

luego nos vamos a api y creamos la ruta, que es sencillo porque ya lo hemos visto
(
//ruta para mostrar mitologia por id
Route::get('/mitologias/{id}', [MitologiasController::class, 'show']);
)

y ahora probar que funcione en la extension thunder client o donde quieras

--------------
DELETE
eliminar una mitologia:

esta funcion será bastanet similar a show, asi que nos vamos al controlador mitologias
y en la funcion delete será asi:

(
   public function destroy($id)
    {
        //
        $mitologia = Mitologias::find($id);//busca mitologia por id
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        $titulo = $mitologia->titulo; // Guarda el título antes de eliminar la mitología
        $mitologia->delete();//elimina mitologia

        $data = [//mensaje de exito
            'message' => 'Mitología eliminada exitosamente',
            'titulo' => $titulo,
            'status' => 200
        ];
        return response()->json($data, 200);
    }
)
y la diferencia es que aqui usaremos delete() tambien guardamos titulo de la mitologia antes de borrarlo para mostrar que titulo de mitologia
hemos borrado


en api agregamos simplemente la ruta y listo

(
//ruta para eliminar mitologia por id
Route::delete('/mitologias/{id}', [MitologiasController::class, 'destroy']);
)

------
PUT UPDATE

para actualizar una mitologia tambien buscamos por id pero aqui validamos tambien que los datos que actualizaremos esten correctos
para ello nos vamos a controlador mitologias
y en la funcion update
(
  public function update(Request $request,$id)
    {
        $mitologia = Mitologias::find($id);//busca mitologia por id
        //
        $validator = Validator::make($request->all(), [// Se crean las reglas de validación
            'Historia' => 'required|string|max:4000',
            'titulo' => 'required|string|max:25',
        ]);
        if ($validator->fails()) {// Verifica si la validación falla
            $data = [
                'message' => 'Error de validación',
                'errors' => $validator->errors(),
                'status' => 422
            ];
            return response()->json($data, 422);//retorna mensaje de error
        }
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);//retorna mensaje de error
        }
        try {
            $mitologia->Historia = $request->Historia;//actualiza historia
            $mitologia->titulo = $request->titulo;//actualiza titulo

            $mitologia->save();//actualiza mitologia

            $data = [//mensaje de exito
                'message' => 'Mitología actualizada exitosamente',
                'Mitologia' => $mitologia->titulo,
                'status' => 200
            ];
            return response()->json($data, 200);

        } catch (\Exception $e) {//captura errores
            $data = [
                'message' => 'Error al actualizar la mitología',
                'error' => $e->getMessage(),
                'status' => 500
            ];
            return response()->json($data, 500);//retorna mensaje de error
        }
    }
)

aqui hemos buscado por id, hemos validado que los datos a actualizar sean correctos y ver si la mitologia existia 
con sus respectivos mensajes de error,
luego en un try catch, hemos actualizado los datos buscados por id de la mitologia con los datos enviados en la peticion
en request, y luego guardamos con save. si todo va bien es un mensaje con exito si va mal se usa el catch

luego en api creamos al ruta

(
//ruta para actualizar mitologia por id
Route::put('/mitologias/{id}', [MitologiasController::class, 'update']);
)

y simplemente probamos que funcione

---------------------------
PATCH
CUANDO MODIFICAMOS PARCIALMENTE ALGUNOS DATOS

como queremos modificar no todos los datos de la mitologia haremos casi lo mismo en mitologia controler
con ligeras diferencias:

(
    public function updatePartial(Request $request,$id)
    {
        $mitologia = Mitologias::find($id);//busca mitologia por id
        //
        $validator = Validator::make($request->all(), [// Se crean las reglas de validación
            'Historia' => '|string|max:4000',
            'titulo' => '|string|max:25',
        ]);
        if ($validator->fails()) {// Verifica si la validación falla
            $data = [
                'message' => 'Error de validación',
                'errors' => $validator->errors(),
                'status' => 422
            ];
            return response()->json($data, 422);//retorna mensaje de error
        }
        if (!$mitologia) {//verifica si existe la mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);//retorna mensaje de error
        }
        try {
	    if (!$request->hasAny(['Historia', 'titulo'])) {// Verifica si al menos uno de los campos está presente en la solicitud
                $data = [
                    'message' => 'No se proporcionaron datos para actualizar',
                    'status' => 400
                ];
                return response()->json($data, 400);//retorna mensaje de error
            }
            if ($request->has('Historia')) {
                $mitologia->Historia = $request->Historia;//actualiza historia
            }
            if ($request->has('titulo')) {
                $mitologia->titulo = $request->titulo;//actualiza titulo
            }
            $mitologia->save();//actualiza mitologia
            $data = [//mensaje de exito
                'message' => 'Mitología actualizada exitosamente',
                'Mitologia' => $mitologia->titulo,
                'status' => 200
            ];
            return response()->json($data, 200);

        } catch (\Exception $e) {//captura errores
            $data = [
                'message' => 'Error al actualizar la mitología',
                'error' => $e->getMessage(),
                'status' => 500
            ];
            return response()->json($data, 500);//retorna mensaje de error
        }
    }
)
DIFERENCIAS CON LA FUNCION UPDATE:
-CON hasAny COMPROBAMOS QUE ALMENOS UNO DE LOS CAMPOS NO ESTE VACIO      
-EN VALIDATOR los datos no tienen required  por lo que no dara error si llegan vacios en la peticion
-EN EL TRY CUANDO QUEREMOS MODIFICAR LOS DATOS DE MITOLOGIAS usamos un if para modificar si el campo del request no esta vacio,
 si esta vacio no se modifica

luego nos vamos a api y creamos la ruta
(
//ruta para actualizar parcialmente la mitologia por id
Route::patch('/mitologias/{id}', [MitologiasController::class, 'updatePartial']);
)

y luego simplemente probamos que se modifiquen sin presentar todos los datos y los datos que no estamos modificando que no se cambien

------------
ASOCIAR USUARIO Y MITOLOGIA 
no es obligatoria la asociacion entre estas 2 tablas por lo que
se creará otra funcion/peticion dentro del modelo controlador

(
use App\Models\User;

 //asociar mitologia a usuario (guardar mitologia)
    public function attachUser($IdMitologia, $IdUsuario)
    {
        // Encuentra la mitología y el usuario por sus IDs
        $mitologia = Mitologias::find($IdMitologia);
        $usuario = User::find($IdUsuario);

        if(!$mitologia){//verifica si existe mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        if(!$usuario){//verifica si existe usuario
            $data = [
                'message' => 'Usuario no encontrado',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        // Asocia al usuario con la mitología:
        //usuariosQueGuardaron es el nombre de la funcion en el MODELO Mitologias para
        //  la relacion muchos a muchos, por eso viene de $mitologia
        $mitologia->usuariosQueGuardaron()->syncWithoutDetaching([$usuario->id]);// Evita duplicados
        return response()->json([
            'message' => "Usuario {$usuario->id} asociado a la mitología {$mitologia->id}"
        ]);
    }
)

aqui hacemos lo siguiente:
-importamos modelo user para buscar por id el usuario que queremos asociar
- verificaciones de que exista mitologia user
- utilizamos $mitologia y buscamos la funcion para asociar usuario que creamos en los inicios de la instrucciones
	usuariosQueGuardaron() y la unimos con syncWithoutDetaching para evitar duplicaciones, y mandamos el id de usuario

luego vamos y craemos la peticion post:

//ruta para asociar un usuario a una mitologia (guardar mitologia)
Route::post('/mitologias/{IdMitologia}/users/{IdUsuario}', [MitologiasController::class, 'attachUser']);

----------------------
ELIMINAR ASOSIACION 
ES MUY SIMILAR A ASOCIAR TABLAS PERO NO USAMOS syncWithoutDetaching()
y usamos detach()

(
    public function detachUser($IdMitologia, $IdUsuario)
    {
        // Encuentra la mitología y el usuario por sus IDs
        $mitologia = Mitologias::find($IdMitologia);
        $usuario = User::find($IdUsuario);

        if(!$mitologia){//verifica si existe mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        if(!$usuario){//verifica si existe usuario
            $data = [
                'message' => 'Usuario no encontrado',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        // DESASOCIA al usuario con la mitología:
        //usuariosQueGuardaron es el nombre de la funcion en el MODELO Mitologias para
        //  la relacion muchos a muchos, por eso viene de $mitologia
        $mitologia->usuariosQueGuardaron()->detach([$usuario->id]);
        return response()->json([
            'message' => "Usuario {$usuario->id} desasociado de la mitología {$mitologia->id}"
        ]);
    }
)
aqui hacemos:
-Repito solo cambiamos syncWithoutDetaching() por detach()
-hacemos algunos cambios menores en mensajes de borrar asociacion

creamos la peticion en api

//ruta para desasociar un usuario de una mitologia (quitar mitologia guardada)
Route::delete('/mitologias/{IdMitologia}/users/{IdUsuario}', [MitologiasController::class, 'detachUser']);

---------------------------
GET USUARIOS ASOCIADOS A MITOLOGIAS
lo que obtendremos son todos los usuarios obtenidos a una especifica mitologia bastante similar a los anteriores unir tablas

(
public function showAttached($IdMitologia)
    {
        // Encuentra la mitología y el usuario por sus IDs
        $mitologia = Mitologias::find($IdMitologia);

        if(!$mitologia){//verifica si existe mitologia
            $data = [
                'message' => 'Mitología no encontrada',
                'status' => 404
            ];
            return response()->json($data, 404);
        }
        // Obtiene los usuarios asociados a la mitología y los guarda en la variable $usuarios
        $usuarios = $mitologia->usuariosQueGuardaron()->select('users.id', 'users.name')->get();
           return response()->json([
                'mitologia_id' => $mitologia->id,
                'usuarios' => $usuarios
            ]);
    }
}
)
aqui hacemos:
-SOLO BUSCAMOS LA MITOLOGIA EN EL ::find
- Creamos una variable $usuarios para obtener mediante un select todos los usuarios asociados a la mitologia especifica
- luego usamos las variables en los mensajes

//ruta para obtener todas las mitologias guardadas por un usuario
Route::get('/mitologias/{IdMitologia}/users', [MitologiasController::class, 'showAttached']);


---------------
GET CON DATOS DE OTRAS TABLAS

fuera de las instrucciones creamos una tabla civilizaciones para evitar duplicacion de datos con mitologia
lo que haremos aqui es modificar index para traer los datos de mitologias y en lugar de civilizacion_id buscamos la civilizacion
asociada a esa id 

(
public function index()
    {
        // Trae todas las mitologías con su civilización relacionada
        $mitologias = Mitologias::with('civilizacion')->get();
        //with carga la relacion de la tabla civilizaciones definida en el modelo Mitologias

        if ($mitologias->isEmpty()) {
            return response()->json([
                'message' => 'No se encontraron mitologías',
                'status' => 404
            ], 404);
        }

        // Transformar los datos para devolver solo lo que queremos
        $result = $mitologias->map(function ($mitologia) {
            return [
                'id' => $mitologia->id,
                'titulo' => $mitologia->titulo,
                'Historia' => $mitologia->Historia,
                'civilizacion' => $mitologia->civilizacion ? $mitologia->civilizacion->civilizacion : null
            ];
        });

        return response()->json([
            'Mitologias' => $result,
            'status' => 200
        ], 200);
    }
)

- con ::with('civilizacion')->get() obtendremos los datos en la tabla civilizaciones
- utilizamos map para mostrar cada mitologia y sus datos correspondientes
- utilizamos operador ternario (? si valor true : si valor false) el cual es medio innecesario segun la logica del programa de necesitar el id de civilizacion




---
EXPLICACIONES QUE FALTAN EN MITOLOGIAS:

-QUE HACER CON LOS ESPACIOS EN EL CAMPO "Historia" DE MITOLOGIAS es decir al ser una historia hay un orden en el texto que se debe seguir
con espacios
-probablemente hacer una funcion para no hacer este codigo cada que quieras verificar que un usuario,mitologia,etc exista
if(!$usuario){//verifica si existe usuario
            $data = [
                'message' => 'Usuario no encontrado',
                'status' => 404
            ];
            return response()->json($data, 404);
        }

c
buen tutorial en youtube https://www.youtube.com/watch?v=eLI8c_NtkBk&t=1165s

